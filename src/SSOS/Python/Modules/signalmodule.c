
/* Signal module -- many thanks to Lance Ellinghaus */

/* XXX Signals should be recorded per thread, now we have thread state. */
#include "Python.h"
#include <signal.h>
#include "clinic/signalmodule.c.h"

/*[clinic input]
module signal
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=b0301a3bde5fe9d3]*/


/*
   NOTES ON THE INTERACTION BETWEEN SIGNALS AND THREADS

   When threads are supported, we want the following semantics:

   - only the main thread can set a signal handler
   - any thread can get a signal handler
   - signals are only delivered to the main thread

   I.e. we don't support "synchronous signals" like SIGFPE (catching
   this doesn't make much sense in Python anyway) nor do we support
   signals as a means of inter-thread communication, since not all
   thread implementations support that (at least our thread library
   doesn't).

   We still have the problem that in some implementations signals
   generated by the keyboard (e.g. SIGINT) are delivered to all
   threads (e.g. SGI), while in others (e.g. Solaris) such signals are
   delivered to one random thread (an intermediate possibility would
   be to deliver it to the main thread -- POSIX?).  For now, we have
   a working implementation that works in all three cases -- the
   handler ignores signals if getpid() isn't the same as in the main
   thread.  XXX This is a hack.
*/

#ifdef WITH_THREAD
#include <sys/types.h> /* For pid_t */
#include "pythread.h"
static long main_thread;
static pid_t main_pid;
#endif

//@SVD NSIG
#define NSIG 23
static volatile struct {
    sig_atomic_t tripped;
    PyObject *func;
} Handlers[NSIG];

/* Speed up sigcheck() when none tripped */
static volatile sig_atomic_t is_tripped = 0;

static PyObject *DefaultHandler;
static PyObject *IgnoreHandler;
static PyObject *IntHandler;

/* On Solaris 8, gcc will produce a warning that the function
declaration is not a prototype. This is caused by the definition of
SIG_DFL as (void (*)())0; the correct declaration would have been
(void (*)(int))0. */
static PyOS_sighandler_t old_siginthandler = SIG_DFL;

static void
finisignal(void)
{
    int i;
    PyObject *func;

    PyOS_setsig(SIGINT, old_siginthandler);
    old_siginthandler = SIG_DFL;

    for (i = 1; i < NSIG; i++) {
        func = Handlers[i].func;
        Handlers[i].tripped = 0;
        Handlers[i].func = NULL;
        if (i != SIGINT && func != NULL && func != Py_None &&
            func != DefaultHandler && func != IgnoreHandler)
            PyOS_setsig(i, SIG_DFL);
        Py_XDECREF(func);
    }

    Py_CLEAR(IntHandler);
    Py_CLEAR(DefaultHandler);
    Py_CLEAR(IgnoreHandler);
}


/* Declared in pyerrors.h */
int
PyErr_CheckSignals(void)
{
    int i;
    PyObject *f;

    if (!is_tripped)
        return 0;

#ifdef WITH_THREAD
    if (PyThread_get_thread_ident() != main_thread)
        return 0;
#endif

    /*
     * The is_tripped variable is meant to speed up the calls to
     * PyErr_CheckSignals (both directly or via pending calls) when no
     * signal has arrived. This variable is set to 1 when a signal arrives
     * and it is set to 0 here, when we know some signals arrived. This way
     * we can run the registered handlers with no signals blocked.
     *
     * NOTE: with this approach we can have a situation where is_tripped is
     *       1 but we have no more signals to handle (Handlers[i].tripped
     *       is 0 for every signal i). This won't do us any harm (except
     *       we're gonna spent some cycles for nothing). This happens when
     *       we receive a signal i after we zero is_tripped and before we
     *       check Handlers[i].tripped.
     */
    is_tripped = 0;

    if (!(f = (PyObject *)PyEval_GetFrame()))
        f = Py_None;

    for (i = 1; i < NSIG; i++) {
        if (Handlers[i].tripped) {
            PyObject *result = NULL;
            PyObject *arglist = Py_BuildValue("(iO)", i, f);
            Handlers[i].tripped = 0;

            if (arglist) {
                result = PyEval_CallObject(Handlers[i].func,
                                           arglist);
                Py_DECREF(arglist);
            }
            if (!result)
                return -1;

            Py_DECREF(result);
        }
    }

    return 0;
}


///* Replacements for intrcheck.c functionality
// * Declared in pyerrors.h
// */
//void
//PyErr_SetInterrupt(void)
//{
//    trip_signal(SIGINT);
//}

void
PyOS_InitInterrupts(void)
{
    PyObject *m = PyImport_ImportModule("_signal");
    if (m) {
        Py_DECREF(m);
    }
}

void
PyOS_FiniInterrupts(void)
{
    finisignal();
}

int
PyOS_InterruptOccurred(void)
{
    if (Handlers[SIGINT].tripped) {
#ifdef WITH_THREAD
        if (PyThread_get_thread_ident() != main_thread)
            return 0;
#endif
        Handlers[SIGINT].tripped = 0;
        return 1;
    }
    return 0;
}

//static void
//_clear_pending_signals(void)
//{
//    int i;
//    if (!is_tripped)
//        return;
//    is_tripped = 0;
//    for (i = 1; i < NSIG; ++i) {
//        Handlers[i].tripped = 0;
//    }
//}

//void
//PyOS_AfterFork(void)
//{
//    /* Clear the signal flags after forking so that they aren't handled
//     * in both processes if they came in just before the fork() but before
//     * the interpreter had an opportunity to call the handlers.  issue9535. */
//    _clear_pending_signals();
//#ifdef WITH_THREAD
//    /* PyThread_ReInitTLS() must be called early, to make sure that the TLS API
//     * can be called safely. */
//    PyThread_ReInitTLS();
//    _PyGILState_Reinit();
//    PyEval_ReInitThreads();
//    main_thread = PyThread_get_thread_ident();
//    main_pid = getpid();
//    _PyImport_ReInitLock();
//#endif
//}

int
_PyOS_IsMainThread(void)
{
#ifdef WITH_THREAD
    return PyThread_get_thread_ident() == main_thread;
#else
    return 1;
#endif
}
//
//#ifdef MS_WINDOWS
//void *_PyOS_SigintEvent(void)
//{
//    /* Returns a manual-reset event which gets tripped whenever
//       SIGINT is received.
//
//       Python.h does not include windows.h so we do cannot use HANDLE
//       as the return type of this function.  We use void* instead. */
//    return sigint_event;
//}
//#endif
